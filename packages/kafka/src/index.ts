/* ====================================================================
 * OmniQueue – Kafka adapter (node-rdkafka, Core vNext)
 * ==================================================================== */
import {
    Broker,
    BrokerMessage,
    ConsumeOptions,
    register,
    SendOptions,
} from '@omniqueue/core';
import Kafka, {
    IAdminClient,
    KafkaConsumer,
    Message,
    MessageHeader,
    Producer,
} from 'node-rdkafka';
import { ulid } from 'ulid';

/* ─────────────── user-supplied connection & defaults ─────────────── */
export interface KafkaConfig {
   /** Bootstrap servers list, e.g. "localhost:9092" */
   brokers: string | string[];
   /** Optional logical client-id (else autogenerated) */
   clientId?: string;
   /** Extra low-level producer / consumer tuning */
   producerConfig?: Kafka.ProducerGlobalConfig;
   consumerConfig?: Kafka.ConsumerGlobalConfig;

   /** Default topic settings used when `ensure` = true */
   defaultTopic?: {
      numPartitions?: number; // default 1
      replicationFactor?: number; // default 1
      configEntries?: Record<string, string>;
   };
}

export type KafkaSendOptions = SendOptions & {
   headers?: MessageHeader[];
};

/* Map logical priority (0-N) → partition index (0-N) */
const prioToPartition = (prio = 0) => prio;

/* =================================================================== */
export class KafkaBroker implements Broker<KafkaSendOptions, ConsumeOptions> {
   readonly provider = 'kafka' as const;
   readonly config: any;

   private producer!: Producer;
   private admin!: IAdminClient;

   constructor(private cfg: KafkaConfig) {
      this.config = cfg;
   }

   /* ------------------ bootstrap connections ------------------------ */
   async init() {
      const bootstrap = Array.isArray(this.cfg.brokers)
         ? this.cfg.brokers.join(',')
         : this.cfg.brokers;

      const common: Kafka.GlobalConfig = {
         'bootstrap.servers': bootstrap,
         'client.id': this.cfg.clientId ?? `omniqueue-${ulid()}`,
      };

      this.admin = Kafka.AdminClient.create(common);

      this.producer = new Kafka.Producer({
         ...common,
         dr_cb: true, // delivery-report callback
         ...this.cfg.producerConfig,
      });

      await new Promise<void>((res, rej) => {
         this.producer.connect({}, (err) => (err ? rej(err) : res()));
      });
   }

   /* ---------------- topic-creation helper -------------------------- */
   private async ensureTopic(
      topic: string,
      opts: Record<string, any> | undefined,
   ) {
      return new Promise<void>((res, rej) => {
         this.admin.createTopic(
            {
               topic,
               num_partitions:
                  opts?.numPartitions ??
                  this.cfg.defaultTopic?.numPartitions ??
                  1,
               replication_factor:
                  opts?.replicationFactor ??
                  this.cfg.defaultTopic?.replicationFactor ??
                  1,
               config:
                  opts?.configEntries ?? this.cfg.defaultTopic?.configEntries,
            },
            (err) => {
               if (
                  err &&
                  err.code !== Kafka.CODES.ERRORS.ERR_TOPIC_ALREADY_EXISTS
               )
                  return rej(err);
               res();
            },
         );
      });
   }

   /* ---------------- point-to-point ------------------------------- */
   async send(
      queue: string,
      msg: Omit<BrokerMessage, 'ack' | 'nack'>,
      opts: KafkaSendOptions = {},
   ): Promise<void> {
      if (opts.ensure) await this.ensureTopic(queue, opts.createOptions);

      await new Promise<void>((res, rej) => {
         this.producer.produce(
            queue,
            prioToPartition(opts.prio),
            Buffer.from(JSON.stringify(msg.body)),
            msg.id, // key → stick to same partition on retries
            Date.now(),
            undefined,
            opts.headers??[]
         );
      });
   }

   async receive(
      queue: string,
      handler: (m: BrokerMessage) => Promise<void>,
      opts: ConsumeOptions,
   ): Promise<void> {
      if (!opts?.group)
         throw new Error('`group` is mandatory in ConsumeOptions');
      if (opts.ensure) await this.ensureTopic(queue, opts.createOptions);

      const consumer: KafkaConsumer = new Kafka.KafkaConsumer(
         {
            'bootstrap.servers': Array.isArray(this.cfg.brokers)
               ? this.cfg.brokers.join(',')
               : this.cfg.brokers,
            'group.id': opts.group,
            'enable.auto.commit': false,
            ...this.cfg.consumerConfig,
         },
         {},
      );

      await new Promise<void>((res, rej) => {
         consumer.connect({}, (err: any) => (err ? rej(err) : res()));
      });

      consumer.subscribe([queue]);
      consumer.consume();

      consumer.on('data', async (raw: Message) => {
         const brokerMsg: BrokerMessage = {
            id: raw.key?.toString() ?? ulid(),
            body: JSON.parse(raw.value!.toString()),
            headers: (raw.headers as any) ?? {},
            ack: async () => {
               await consumer.commit(raw);
            },
            nack: async () => {
               /* do nothing → redeliver */
            },
         };
         try {
            await handler(brokerMsg);
            await brokerMsg.ack();
         } catch {
            await brokerMsg.nack();
         }
      });
   }

   /* --------------- fan-out (same publish semantics) --------------- */
   async publish(
      topic: string,
      msg: Omit<BrokerMessage, 'ack' | 'nack'>,
      opts: KafkaSendOptions = {},
   ): Promise<void> {
      await this.send(topic, msg, opts); // fan-out happens via groups
   }

   async subscribe(
      topic: string,
      handler: (m: BrokerMessage) => Promise<void>,
      opts: ConsumeOptions,
   ): Promise<void> {
      await this.receive(topic, handler, opts);
   }

   /* ------------- lifecycle / teardown ---------------------------- */
   async close(): Promise<void> {
      await new Promise((r) => this.producer.disconnect(r));
      await new Promise((r) => {
         this.admin.disconnect();
         r(0);
      });
   }
}

/* Register with OmniQueue core */
register('kafka', async (cfg: KafkaConfig) => {
   const broker = new KafkaBroker(cfg);
   // private init before first use
   await (broker as any).init();
   return broker;
});
